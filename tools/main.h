#pragma once
#include <stdio.h>
#include <stdint.h>

#define RK33_V1_MAGIC 0x0ff0aa55
#define RKNS_V2_MAGIC 0x534e4b52

#define RK_NO_CHECKSUM 0x4000
#define RK_SHA256_CHECKSUM 0x0

// Rockchip's encryption key
static const unsigned char rockchip_key[16] = {
	124, 78, 3, 4, 85, 5, 9, 7, 45, 44, 123, 56, 23, 13, 23, 17
};

struct __attribute__((packed)) RkHeaderV1 {
	uint32_t signature;
	uint32_t reserved;
	uint32_t disable_rc4;
	uint16_t init_offset;
	uint8_t reserved1[492];
	uint16_t init_size;
	uint16_t init_boot_size;
	uint16_t reserved2;
	// (512 bytes)
};

struct __attribute__((packed)) RkHeaderV2 {
	uint32_t signature;
	uint32_t res1;
	uint16_t hash_field_offset;
	uint16_t n_images;
	uint32_t boot_flag;
	uint8_t res2[0x68];
	struct ImageEntry {
		uint16_t offset;
		uint16_t size;
		uint16_t address;
		uint32_t flag;
		uint32_t counter;
		uint8_t res[8];
		uint8_t hash[0x40];
	}images[4];
};
_Static_assert(__builtin_offsetof(struct RkHeaderV2, images) == 0x78, "offset check failed");

static unsigned int crc_sum_16(unsigned int crc, uint8_t *ptr, unsigned int len) {
	const uint16_t table_16[] = {0x0, 0x1021, 0x2042, 0x3063, 0x4084, 0x50a5, 0x60c6, 0x70e7, 0x8108, 0x9129, 0x0a14a, 0x0b16b, 0x0c18c, 0x0d1ad, 0x0e1ce, 0x0f1ef, 0x1231, 0x210, 0x3273, 0x2252, 0x52b5, 0x4294, 0x72f7, 0x62d6, 0x9339, 0x8318, 0x0b37b, 0x0a35a, 0x0d3bd, 0x0c39c, 0x0f3ff, 0x0e3de, 0x2462, 0x3443, 0x420, 0x1401, 0x64e6, 0x74c7, 0x44a4, 0x5485, 0x0a56a, 0x0b54b, 0x8528, 0x9509, 0x0e5ee, 0x0f5cf, 0x0c5ac, 0x0d58d, 0x3653, 0x2672, 0x1611, 0x630, 0x76d7, 0x66f6, 0x5695, 0x46b4, 0x0b75b, 0x0a77a, 0x9719, 0x8738, 0x0f7df, 0x0e7fe, 0x0d79d, 0x0c7bc, 0x48c4, 0x58e5, 0x6886, 0x78a7, 0x840, 0x1861, 0x2802, 0x3823, 0x0c9cc, 0x0d9ed, 0x0e98e, 0x0f9af, 0x8948, 0x9969, 0x0a90a, 0x0b92b, 0x5af5, 0x4ad4, 0x7ab7, 0x6a96, 0x1a71, 0x0a50, 0x3a33, 0x2a12, 0x0dbfd, 0x0cbdc, 0x0fbbf, 0x0eb9e, 0x9b79, 0x8b58, 0x0bb3b, 0x0ab1a, 0x6ca6, 0x7c87, 0x4ce4, 0x5cc5, 0x2c22, 0x3c03, 0x0c60, 0x1c41, 0x0edae, 0x0fd8f, 0x0cdec, 0x0ddcd, 0x0ad2a, 0x0bd0b, 0x8d68, 0x9d49, 0x7e97, 0x6eb6, 0x5ed5, 0x4ef4, 0x3e13, 0x2e32, 0x1e51, 0x0e70, 0x0ff9f, 0x0efbe, 0x0dfdd, 0x0cffc, 0x0bf1b, 0x0af3a, 0x9f59, 0x8f78, 0x9188, 0x81a9, 0x0b1ca, 0x0a1eb, 0x0d10c, 0x0c12d, 0x0f14e, 0x0e16f, 0x1080, 0x0a1, 0x30c2, 0x20e3, 0x5004, 0x4025, 0x7046, 0x6067, 0x83b9, 0x9398, 0x0a3fb, 0x0b3da, 0x0c33d, 0x0d31c, 0x0e37f, 0x0f35e, 0x2b1, 0x1290, 0x22f3, 0x32d2, 0x4235, 0x5214, 0x6277, 0x7256, 0x0b5ea, 0x0a5cb, 0x95a8, 0x8589, 0x0f56e, 0x0e54f, 0x0d52c, 0x0c50d, 0x34e2, 0x24c3, 0x14a0, 0x481, 0x7466, 0x6447, 0x5424, 0x4405, 0x0a7db, 0x0b7fa, 0x8799, 0x97b8, 0x0e75f, 0x0f77e, 0x0c71d, 0x0d73c, 0x26d3, 0x36f2, 0x691, 0x16b0, 0x6657, 0x7676, 0x4615, 0x5634, 0x0d94c, 0x0c96d, 0x0f90e, 0x0e92f, 0x99c8, 0x89e9, 0x0b98a, 0x0a9ab, 0x5844, 0x4865, 0x7806, 0x6827, 0x18c0, 0x8e1, 0x3882, 0x28a3, 0x0cb7d, 0x0db5c, 0x0eb3f, 0x0fb1e, 0x8bf9, 0x9bd8, 0x0abbb, 0x0bb9a, 0x4a75, 0x5a54, 0x6a37, 0x7a16, 0x0af1, 0x1ad0, 0x2ab3, 0x3a92, 0x0fd2e, 0x0ed0f, 0x0dd6c, 0x0cd4d, 0x0bdaa, 0x0ad8b, 0x9de8, 0x8dc9, 0x7c26, 0x6c07, 0x5c64, 0x4c45, 0x3ca2, 0x2c83, 0x1ce0, 0x0cc1, 0x0ef1f, 0x0ff3e, 0x0cf5d, 0x0df7c, 0x0af9b, 0x0bfba, 0x8fd9, 0x9ff8, 0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0};
	for (int i = 0; i < len; i++) {
		crc = (table_16[((crc >> 8) ^ ptr[i]) & 0xff] ^ (crc << 8)) & 0xffff;
	}
	return crc;
}

struct Rc4Encoder {
	unsigned int j;
	unsigned int x;
	uint8_t key[256];
};

static int rc4_encode_chunk(struct Rc4Encoder *r, uint8_t *buf, unsigned int len) {
    for (int i = 0; i < len; i++) {
        r->x = (r->x + 1) % 256;
        r->j = (r->j + r->key[r->x]) % 256;
		uint8_t temp = r->key[r->x];
        r->key[r->x] = r->key[r->j];
        r->key[r->j] = temp;
        buf[i] ^= r->key[(r->key[r->x] + r->key[r->j]) % 256];
    }
	return 0;
}

static void setup_rc4_encoder(struct Rc4Encoder *r, const unsigned char key[16]) {
    for (int i = 0; i < 256; i++) {
        r->key[i] = i;
    }

    int j = 0;
    for (int i = 0; i < 256; i++) {
        j = (j + r->key[i] + key[i % 16]) % 256;
        uint8_t temp = r->key[i];
        r->key[i] = r->key[j];
        r->key[j] = temp;
    }

	r->j = 0;
	r->x = 0;
}

static void rc4_encode(uint8_t *buf, unsigned int len, const uint8_t key[16]) {
	struct Rc4Encoder r;
	setup_rc4_encoder(&r, key);
	rc4_encode_chunk(&r, buf, len);
}

#ifdef TEST_CRYPTO
int main(void) {
	uint8_t dat[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
	printf("crc16: %04x\n", crc_sum_16(0xffff, dat, sizeof(dat)));

	struct Rc4Encoder r;
	setup_rc4_encoder(&r, rockchip_key);
	rc4_encode_chunk(&r, dat, sizeof(dat));
	printf("j: %x x: %x\n", r.j, r.x);
}
#endif
