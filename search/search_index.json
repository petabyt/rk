{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Rockchip bare metal reference This is a work-in-progress resource for bare-metal bringup for Rockchip devices. Source code: https://github.com/petabyt/rk For questions: daniel (AT) futo.org Copyright FUTO (C) 2025 FUTO","title":"Rockchip bare metal reference"},{"location":"#rockchip-bare-metal-reference","text":"This is a work-in-progress resource for bare-metal bringup for Rockchip devices. Source code: https://github.com/petabyt/rk For questions: daniel (AT) futo.org Copyright FUTO (C) 2025 FUTO","title":"Rockchip bare metal reference"},{"location":"custom_ddr_image/","text":"Custom DDR images A custom DDR image for the RK3399 can be made with an assembly stub like this: .global _start _start: .int 0x33334b52 // rk33 b shim // second u32 is blank, so jump elsewhere bin: .incbin \"../../img/rk3399_ddr_933MHz_v1.30.bin\", 8 // Minimal shim to do stuff before running ddr image shim: stp x0, x1, [sp, #-0x10]! stp x2, x3, [sp, #-0x10]! stp x4, x5, [sp, #-0x10]! stp x6, x7, [sp, #-0x10]! stp x8, x9, [sp, #-0x10]! stp x10, x11, [sp, #-0x10]! stp x12, x13, [sp, #-0x10]! stp x14, x15, [sp, #-0x10]! stp x16, x17, [sp, #-0x10]! stp x18, x30, [sp, #-0x10]! .extern ddr_shim bl ddr_shim ldp x18, x30, [sp], #0x10 ldp x16, x17, [sp], #0x10 ldp x14, x15, [sp], #0x10 ldp x12, x13, [sp], #0x10 ldp x10, x11, [sp], #0x10 ldp x8, x9, [sp], #0x10 ldp x6, x7, [sp], #0x10 ldp x4, x5, [sp], #0x10 ldp x2, x3, [sp], #0x10 ldp x0, x1, [sp], #0x10 b bin ddr_shim can perform early power-up tasks, such as turning on power domains, GPIO pins, etc. Allowing devices to power on while DDR is initialized makes it boot slightly faster.","title":"Custom DDR images"},{"location":"custom_ddr_image/#custom-ddr-images","text":"A custom DDR image for the RK3399 can be made with an assembly stub like this: .global _start _start: .int 0x33334b52 // rk33 b shim // second u32 is blank, so jump elsewhere bin: .incbin \"../../img/rk3399_ddr_933MHz_v1.30.bin\", 8 // Minimal shim to do stuff before running ddr image shim: stp x0, x1, [sp, #-0x10]! stp x2, x3, [sp, #-0x10]! stp x4, x5, [sp, #-0x10]! stp x6, x7, [sp, #-0x10]! stp x8, x9, [sp, #-0x10]! stp x10, x11, [sp, #-0x10]! stp x12, x13, [sp, #-0x10]! stp x14, x15, [sp, #-0x10]! stp x16, x17, [sp, #-0x10]! stp x18, x30, [sp, #-0x10]! .extern ddr_shim bl ddr_shim ldp x18, x30, [sp], #0x10 ldp x16, x17, [sp], #0x10 ldp x14, x15, [sp], #0x10 ldp x12, x13, [sp], #0x10 ldp x10, x11, [sp], #0x10 ldp x8, x9, [sp], #0x10 ldp x6, x7, [sp], #0x10 ldp x4, x5, [sp], #0x10 ldp x2, x3, [sp], #0x10 ldp x0, x1, [sp], #0x10 b bin ddr_shim can perform early power-up tasks, such as turning on power domains, GPIO pins, etc. Allowing devices to power on while DDR is initialized makes it boot slightly faster.","title":"Custom DDR images"},{"location":"intro/","text":"Getting started Development The best way to setup a rockchip device for bare-metal development is by enabling the 'maskrom' interface that allows custom images to be loaded over an OTG port. In order to get this working, you have to make all bootable mediums un-bootable by the bootrom. This includes emmc, any SPI flash, or sdmmc. You don't have to completely erase these devices, you just need to erase the rockchip magic at the start ( RKNS or RK33 ) This wiki has instructions for how to do this on various rockchip devices, see Devices/ For most devices you will need a usb-c to usb-a data cable to plug it into your dev machine. In other cases you will need a usb-a to usb-a cable. Once you get your rockchip device setup and plugged in (check dmesg -w ), you will need a tool to send the images over USB. This repo includes a tool ( make rock.out ) that can do this. You can also use xrock . For RK3399 devices: xrock <ddr_img> <os_img> ./rock.out --v1 --ddr <ddr_img> --os <os_img> For RK3588 devices: xrock <ddr_img> <os_img> --rc4-off ./rock.out --v2 --ddr <ddr_img> --os <os_img> How to program Rockchip hardware The best way to learn how to program certain Rockchip hardware is study the its device tree file. A device tree describes how all the hardware in a device is wired and setup, and how to configure it (turning on GPIO pins, changing iomux functions) It will map devices such as fans, LEDs, I2C devices, screens, any other non-enumerable hardware. For example, here's the DTS file for the Genbook: https://github.com/torvalds/linux/blob/master/arch/arm64/boot/dts/rockchip/rk3588-coolpi-cm5-genbook.dts Schematics, if available, are also just as useful. Memory On the RK3588, physical memory from 0x0 - 0xa00000 appears to be reserved for secure world only. If you try and execute code in non-secure state (EL0-EL2) then you'll get a '32-bit instruction trap' exception brought up in EL3. The RK3399 has the same situation but the range is 0x0 - 0x200000 .","title":"Getting started"},{"location":"intro/#getting-started","text":"","title":"Getting started"},{"location":"intro/#development","text":"The best way to setup a rockchip device for bare-metal development is by enabling the 'maskrom' interface that allows custom images to be loaded over an OTG port. In order to get this working, you have to make all bootable mediums un-bootable by the bootrom. This includes emmc, any SPI flash, or sdmmc. You don't have to completely erase these devices, you just need to erase the rockchip magic at the start ( RKNS or RK33 ) This wiki has instructions for how to do this on various rockchip devices, see Devices/ For most devices you will need a usb-c to usb-a data cable to plug it into your dev machine. In other cases you will need a usb-a to usb-a cable. Once you get your rockchip device setup and plugged in (check dmesg -w ), you will need a tool to send the images over USB. This repo includes a tool ( make rock.out ) that can do this. You can also use xrock . For RK3399 devices: xrock <ddr_img> <os_img> ./rock.out --v1 --ddr <ddr_img> --os <os_img> For RK3588 devices: xrock <ddr_img> <os_img> --rc4-off ./rock.out --v2 --ddr <ddr_img> --os <os_img>","title":"Development"},{"location":"intro/#how-to-program-rockchip-hardware","text":"The best way to learn how to program certain Rockchip hardware is study the its device tree file. A device tree describes how all the hardware in a device is wired and setup, and how to configure it (turning on GPIO pins, changing iomux functions) It will map devices such as fans, LEDs, I2C devices, screens, any other non-enumerable hardware. For example, here's the DTS file for the Genbook: https://github.com/torvalds/linux/blob/master/arch/arm64/boot/dts/rockchip/rk3588-coolpi-cm5-genbook.dts Schematics, if available, are also just as useful.","title":"How to program Rockchip hardware"},{"location":"intro/#memory","text":"On the RK3588, physical memory from 0x0 - 0xa00000 appears to be reserved for secure world only. If you try and execute code in non-secure state (EL0-EL2) then you'll get a '32-bit instruction trap' exception brought up in EL3. The RK3399 has the same situation but the range is 0x0 - 0x200000 .","title":"Memory"},{"location":"ref/","text":"References Tool to decode exception syndrome register: https://esr.arm64.dev/ Intro to eDP: https://www.vesa.org/wp-content/uploads/2010/12/DisplayPort-DevCon-Presentation-eDP-Dec-2010-v3.pdf eDP technical overview: https://www.vesa.org/wp-content/uploads/2011/01/ICCE-Presentation-on-VESA-DisplayPort.pdf DisplayPort Specification (covers DPCD): https://glenwing.github.io/docs/DP-1.1.pdf arm-trusted-firmware: https://github.com/ARM-software/arm-trusted-firmware Dynamic Memory Controller: https://www.kernel.org/doc/Documentation/devicetree/bindings/devfreq/rk3399_dmc.txt ARM GIC architecture specification: https://developer.arm.com/documentation/ihi0069/latest/ RK3588 edk2 uefi monorepo: https://gitlab.com/rk3588_linux/rk/uefi-monorepo (Lots of early bare-metal rk3588 code written by rockchip employees, good reference for when the TRM is missing info) rkdocs: https://github.com/axlrose/rkdocs (thanks Axl Rose) TRM/Datasheet: https://github.com/FanX-Tek/rk3588-TRM-and-Datasheet RK3588 Base: https://github.com/torvalds/linux/blob/master/arch/arm64/boot/dts/rockchip/rk3588-base.dtsi pinctrl https://github.com/torvalds/linux/blob/master/arch/arm64/boot/dts/rockchip/rk3588-base-pinctrl.dtsi RK3399 RK3399 TRM v1.4: https://opensource.rock-chips.com/images/e/ee/Rockchip_RK3399TRM_V1.4_Part1-20170408.pdf RK3399 TRM V1.3 Part2: https://rockchip.fr/Rockchip%20RK3399%20TRM%20V1.3%20Part2.pdf 2022 Pinebook Pro main board schematic: https://files.pine64.org/doc/PinebookPro/pinebookpro_schematic_v21a_20220419.pdf rk3399 bootrom analysis: https://github.com/trebisky/Rockchip/blob/4c4623e3df37f01d1d1ae0131fec5bc75f9e8463/bootrom/bootrom.txt If you would like my analysis of the RK3399 and RK3588 bootroms, please email me.","title":"References"},{"location":"ref/#references","text":"Tool to decode exception syndrome register: https://esr.arm64.dev/ Intro to eDP: https://www.vesa.org/wp-content/uploads/2010/12/DisplayPort-DevCon-Presentation-eDP-Dec-2010-v3.pdf eDP technical overview: https://www.vesa.org/wp-content/uploads/2011/01/ICCE-Presentation-on-VESA-DisplayPort.pdf DisplayPort Specification (covers DPCD): https://glenwing.github.io/docs/DP-1.1.pdf arm-trusted-firmware: https://github.com/ARM-software/arm-trusted-firmware Dynamic Memory Controller: https://www.kernel.org/doc/Documentation/devicetree/bindings/devfreq/rk3399_dmc.txt ARM GIC architecture specification: https://developer.arm.com/documentation/ihi0069/latest/","title":"References"},{"location":"ref/#rk3588","text":"edk2 uefi monorepo: https://gitlab.com/rk3588_linux/rk/uefi-monorepo (Lots of early bare-metal rk3588 code written by rockchip employees, good reference for when the TRM is missing info) rkdocs: https://github.com/axlrose/rkdocs (thanks Axl Rose) TRM/Datasheet: https://github.com/FanX-Tek/rk3588-TRM-and-Datasheet RK3588 Base: https://github.com/torvalds/linux/blob/master/arch/arm64/boot/dts/rockchip/rk3588-base.dtsi pinctrl https://github.com/torvalds/linux/blob/master/arch/arm64/boot/dts/rockchip/rk3588-base-pinctrl.dtsi","title":"RK3588"},{"location":"ref/#rk3399","text":"RK3399 TRM v1.4: https://opensource.rock-chips.com/images/e/ee/Rockchip_RK3399TRM_V1.4_Part1-20170408.pdf RK3399 TRM V1.3 Part2: https://rockchip.fr/Rockchip%20RK3399%20TRM%20V1.3%20Part2.pdf 2022 Pinebook Pro main board schematic: https://files.pine64.org/doc/PinebookPro/pinebookpro_schematic_v21a_20220419.pdf rk3399 bootrom analysis: https://github.com/trebisky/Rockchip/blob/4c4623e3df37f01d1d1ae0131fec5bc75f9e8463/bootrom/bootrom.txt If you would like my analysis of the RK3399 and RK3588 bootroms, please email me.","title":"RK3399"},{"location":"devices/genbook/","text":"Genbook / Cool-pi notebook Photos: https://www.flickr.com/photos/201609787@N08/albums/72177720322040367/ The Genbook comes with U-boot SPL on the SPI flash, you can make it unbootable like so: printf '\\x00\\x00\\x00\\x00' | dd of=/dev/mtdblock0 bs=1 seek=$((0x10000)) count=4 conv=notrunc printf '\\x00\\x00\\x00\\x00' | dd of=/dev/mtdblock0 bs=1 seek=$((0x60000)) count=4 conv=notrunc The boot image in SPI flash must have two copies (at 0x10000 and 0x60000 ) so we need to cripple both or the bootrom will load the unmodified copy. The bootrom maskrom mode exposes itself on the left side USB-C port. To boot back into u-boot: xrock maskrom rk3588_ddr_lp4_2112MHz_lp5_2400MHz_v1.16.bin u-boot-genbook.bin --rc4-off The 'loader key' button on the bottom will disable all boot methods (SPI, emmc) and get the bootrom into maskrom mode. In order to erase the emmc from maskrom mode: xrock maskrom rk3588_ddr_lp4_2112MHz_lp5_2400MHz_v1.16.bin rk3588_usbplug_v1.11.bin --rc4-off xrock flash erase 0 100000 in order to erase the SPI: xrock maskrom rk3588_ddr_lp4_2112MHz_lp5_2400MHz_v1.16.bin rk3588_usbplug_v1.11.bin --rc4-off # I didn't see an option to erase loader/SPI flash, so I just wrote a random 30mb file. rkdeveloptool wl 0 '/home/daniel/Downloads/fpupdate-output-xa2-loader.bin'","title":"Genbook / Cool-pi notebook"},{"location":"devices/genbook/#genbook-cool-pi-notebook","text":"Photos: https://www.flickr.com/photos/201609787@N08/albums/72177720322040367/ The Genbook comes with U-boot SPL on the SPI flash, you can make it unbootable like so: printf '\\x00\\x00\\x00\\x00' | dd of=/dev/mtdblock0 bs=1 seek=$((0x10000)) count=4 conv=notrunc printf '\\x00\\x00\\x00\\x00' | dd of=/dev/mtdblock0 bs=1 seek=$((0x60000)) count=4 conv=notrunc The boot image in SPI flash must have two copies (at 0x10000 and 0x60000 ) so we need to cripple both or the bootrom will load the unmodified copy. The bootrom maskrom mode exposes itself on the left side USB-C port. To boot back into u-boot: xrock maskrom rk3588_ddr_lp4_2112MHz_lp5_2400MHz_v1.16.bin u-boot-genbook.bin --rc4-off The 'loader key' button on the bottom will disable all boot methods (SPI, emmc) and get the bootrom into maskrom mode. In order to erase the emmc from maskrom mode: xrock maskrom rk3588_ddr_lp4_2112MHz_lp5_2400MHz_v1.16.bin rk3588_usbplug_v1.11.bin --rc4-off xrock flash erase 0 100000 in order to erase the SPI: xrock maskrom rk3588_ddr_lp4_2112MHz_lp5_2400MHz_v1.16.bin rk3588_usbplug_v1.11.bin --rc4-off # I didn't see an option to erase loader/SPI flash, so I just wrote a random 30mb file. rkdeveloptool wl 0 '/home/daniel/Downloads/fpupdate-output-xa2-loader.bin'","title":"Genbook / Cool-pi notebook"},{"location":"devices/orangepi/","text":"Orange Pi Orange Pi 5 Pro RK3588s Booting over OTG: Erase the emmc flash. Boot with USB-C power, and a USB-A to USB-A cable plugged into the top left USB3 port. Orange Pi 4 LTS RK3399 Same RAM config as the Pinebook Pro Booting over OTG: Erase flash. Use USB-C for power and OTG like on the pinebook. Orange Pi 5/5B RK3588s","title":"Orange Pi"},{"location":"devices/orangepi/#orange-pi","text":"","title":"Orange Pi"},{"location":"devices/orangepi/#orange-pi-5-pro","text":"RK3588s Booting over OTG: Erase the emmc flash. Boot with USB-C power, and a USB-A to USB-A cable plugged into the top left USB3 port.","title":"Orange Pi 5 Pro"},{"location":"devices/orangepi/#orange-pi-4-lts","text":"RK3399 Same RAM config as the Pinebook Pro Booting over OTG: Erase flash. Use USB-C for power and OTG like on the pinebook.","title":"Orange Pi 4 LTS"},{"location":"devices/orangepi/#orange-pi-55b","text":"RK3588s","title":"Orange Pi 5/5B"},{"location":"devices/pinebook/","text":"Pinebook Pro Getting USB-OTG boot working Erase anyting installed on SPI flash Disable eMMC Press power button for 1-2 seconds Device with idVendor=2207, idProduct=330c should be connected eMMC DIP switch","title":"Pinebook Pro"},{"location":"devices/pinebook/#pinebook-pro","text":"","title":"Pinebook Pro"},{"location":"devices/pinebook/#getting-usb-otg-boot-working","text":"Erase anyting installed on SPI flash Disable eMMC Press power button for 1-2 seconds Device with idVendor=2207, idProduct=330c should be connected","title":"Getting USB-OTG boot working"},{"location":"devices/pinebook/#emmc-dip-switch","text":"","title":"eMMC DIP switch"},{"location":"rk3399/boot/","text":"RK3399 Boot process All cores of all clusters enter the bootrom on reset. The first few instructions of the bootrom look like this: // sram offsets - these are different for rk33xx and rk35xx chips uint32_t *sram_a = (uint32_t *)0xffff00e0; uint32_t *sram_b = (uint32_t *)0xffff00e8; if (mpidr_el1 != 0) { while (*sram_a != 0xdeadbeaf) { asm(\"wfe\"); } typedef void entry(void); ((entry *)(*sram_b))(); // undefined } The bootrom supports booting over SPI, eMMC, SDMMC, and USB-OTG. All of these boot methods load both a DDR image (blob that sets up the memory controller) and an OS image. // ... (clock setup, ddr stuff, efuse, etc) ... // Try all boot methods // each boot method has check(), load_ddr(), and load_main() functions. try_boot_methods(); // Bring up the USB3 DWC3 controller into device mode and start accepting control transfers dwc3_usb_spin(); while (1); For USB-OTG, the bootrom exposes itself as a device on a USB-C (or USB-A) port and accepts control transfers for both images. For all other boot methods, an image with an ID block (at offset 0x8000 ) is required, which tells the bootrom at what offset the DDR/OS images are, as well as other setting.","title":"Boot"},{"location":"rk3399/boot/#rk3399-boot-process","text":"All cores of all clusters enter the bootrom on reset. The first few instructions of the bootrom look like this: // sram offsets - these are different for rk33xx and rk35xx chips uint32_t *sram_a = (uint32_t *)0xffff00e0; uint32_t *sram_b = (uint32_t *)0xffff00e8; if (mpidr_el1 != 0) { while (*sram_a != 0xdeadbeaf) { asm(\"wfe\"); } typedef void entry(void); ((entry *)(*sram_b))(); // undefined } The bootrom supports booting over SPI, eMMC, SDMMC, and USB-OTG. All of these boot methods load both a DDR image (blob that sets up the memory controller) and an OS image. // ... (clock setup, ddr stuff, efuse, etc) ... // Try all boot methods // each boot method has check(), load_ddr(), and load_main() functions. try_boot_methods(); // Bring up the USB3 DWC3 controller into device mode and start accepting control transfers dwc3_usb_spin(); while (1); For USB-OTG, the bootrom exposes itself as a device on a USB-C (or USB-A) port and accepts control transfers for both images. For all other boot methods, an image with an ID block (at offset 0x8000 ) is required, which tells the bootrom at what offset the DDR/OS images are, as well as other setting.","title":"RK3399 Boot process"},{"location":"rk3399/disp/","text":"VOP 6 layers supported Background color 4 Window Layers Hardware Cursor Layer Hardware alpha blending VOP Setup process Select reference clock Set VOP to L or B ( grf.edp_lcdc_sel ) Setup and lock PLL Set to standby mode Enable desired interface (such as eDP) and disable unneeded interfaces Configure display settings Configure window layers settings Width, height Porch offsets Enable the window(s) Set format (eg, ARGB888) Set framebuffer address (win0_yrgb_mst) Set reg_cfg_done to 0b1 . The framebuffer is fetched over AXI from DDR. eDP TX Setup process Setup reference clock Wait for HDP Set SW_FUNC_EN_N to normal operation dp_pd = 0 Reset PLL Wait until PLL is locked Setup AUX channel to get DPCD (optional) Enable AUX AUX_FUNC_EN_N Clear AUX interrupts Disable AUX, set aux defer setting, enable AUX Set AUX channel module to normal func_en_2 Enable all function and video modes (func_en_1) Perform a AUX DPCD transfer to get display info ( aux_ registers) Get the display resolution Get the lane count and link rate Set link_bw_set and lane_count_set Link training Link rates, clock recovery, etc This can be skipped Make sure eDP clock is on Disable video mute Enable video output","title":"VOP"},{"location":"rk3399/disp/#vop","text":"6 layers supported Background color 4 Window Layers Hardware Cursor Layer Hardware alpha blending","title":"VOP"},{"location":"rk3399/disp/#vop-setup-process","text":"Select reference clock Set VOP to L or B ( grf.edp_lcdc_sel ) Setup and lock PLL Set to standby mode Enable desired interface (such as eDP) and disable unneeded interfaces Configure display settings Configure window layers settings Width, height Porch offsets Enable the window(s) Set format (eg, ARGB888) Set framebuffer address (win0_yrgb_mst) Set reg_cfg_done to 0b1 . The framebuffer is fetched over AXI from DDR.","title":"VOP Setup process"},{"location":"rk3399/disp/#edp-tx-setup-process","text":"Setup reference clock Wait for HDP Set SW_FUNC_EN_N to normal operation dp_pd = 0 Reset PLL Wait until PLL is locked Setup AUX channel to get DPCD (optional) Enable AUX AUX_FUNC_EN_N Clear AUX interrupts Disable AUX, set aux defer setting, enable AUX Set AUX channel module to normal func_en_2 Enable all function and video modes (func_en_1) Perform a AUX DPCD transfer to get display info ( aux_ registers) Get the display resolution Get the lane count and link rate Set link_bw_set and lane_count_set Link training Link rates, clock recovery, etc This can be skipped Make sure eDP clock is on Disable video mute Enable video output","title":"eDP TX Setup process"},{"location":"rk3588/boot/","text":"RK3588 bare metal bringup Everything needed to bring up common hardware. You will need the official rockchip-developed ddr image: https://github.com/rockchip-linux/rkbin/blob/master/bin/rk35/rk3588_ddr_lp4_2112MHz_lp5_2400MHz_v1.18.bin See bootrom.md Secure GRF init A small sequence (100LoC) is needed to mark needed memory regions as secure. This is done primarily through the main SGRF (Secure General Register File). There are actually a few SGRFs, and they are all undocumented. This is necessary in order to use the VOP and setup a framebuffer. PMU A few power domains need to be brought up in order to make some hardware accessible. These onboard devices are completely powered off on reset. If you try to read/write to their MMIO addresses, you will get a translation error. PD_PHP PD_PCIE PD_GMAC PD_SECURE PD_VOP PD_VO0 PD_VO1 Powering on a power domain is fairly well documented in the TRM. See src/rk3588/pmu.c for exactly how to do it. Other hardware such as GIC, UART, and other essentials belong to the ALIVE power domain. It is powered up on reset, and cannot be powered off.","title":"RK3588 bare metal bringup"},{"location":"rk3588/boot/#rk3588-bare-metal-bringup","text":"Everything needed to bring up common hardware. You will need the official rockchip-developed ddr image: https://github.com/rockchip-linux/rkbin/blob/master/bin/rk35/rk3588_ddr_lp4_2112MHz_lp5_2400MHz_v1.18.bin See bootrom.md","title":"RK3588 bare metal bringup"},{"location":"rk3588/boot/#secure-grf-init","text":"A small sequence (100LoC) is needed to mark needed memory regions as secure. This is done primarily through the main SGRF (Secure General Register File). There are actually a few SGRFs, and they are all undocumented. This is necessary in order to use the VOP and setup a framebuffer.","title":"Secure GRF init"},{"location":"rk3588/boot/#pmu","text":"A few power domains need to be brought up in order to make some hardware accessible. These onboard devices are completely powered off on reset. If you try to read/write to their MMIO addresses, you will get a translation error. PD_PHP PD_PCIE PD_GMAC PD_SECURE PD_VOP PD_VO0 PD_VO1 Powering on a power domain is fairly well documented in the TRM. See src/rk3588/pmu.c for exactly how to do it. Other hardware such as GIC, UART, and other essentials belong to the ALIVE power domain. It is powered up on reset, and cannot be powered off.","title":"PMU"},{"location":"rk3588/bootrom/","text":"RK3588 bootrom function All cores in all clusters will be brought up on boot. All cores but core 0 will enter a wfe loop waiting to be sent to an address. if (mpidr_el1 & 0xffff) != 0 { ((uint32_t)0xffff00e0)[0] = 1; while (((uint32_t)0xffff00e0)[0] != 0xdeadbeaf) { __asm__(\"wfe\"); } typedef core_entry(); core_entry *entry = (core_entry *)(uintptr_t)(((uint32_t)0xffff00e8)[0]); entry(); } boot(); boot() The main boot function does a lot of stuff, mostly with undocumented mmio registers: ddrphy cru crypto saradc After that it runs through a loop bringing up and trying various storage devices looking for one with a valid rockchip signature. FSPI 0 FSPI 1 FSPI 2 FSPI 3 FSPI 4 FSPI 6 eMMC sdmmc Between probing each device, it will try 2 different iomux combinations. If no bootable medium is found, it will bring up a dwc3 gadget on USB3OTG_0 . Once a bootable medium is found, it will load the ddr image from it into sram call it, then load the OS image into dram and run that. Both images are booted into as EL3 in aarch64 mode.","title":"RK3588 bootrom function"},{"location":"rk3588/bootrom/#rk3588-bootrom-function","text":"All cores in all clusters will be brought up on boot. All cores but core 0 will enter a wfe loop waiting to be sent to an address. if (mpidr_el1 & 0xffff) != 0 { ((uint32_t)0xffff00e0)[0] = 1; while (((uint32_t)0xffff00e0)[0] != 0xdeadbeaf) { __asm__(\"wfe\"); } typedef core_entry(); core_entry *entry = (core_entry *)(uintptr_t)(((uint32_t)0xffff00e8)[0]); entry(); } boot();","title":"RK3588 bootrom function"},{"location":"rk3588/bootrom/#boot","text":"The main boot function does a lot of stuff, mostly with undocumented mmio registers: ddrphy cru crypto saradc After that it runs through a loop bringing up and trying various storage devices looking for one with a valid rockchip signature. FSPI 0 FSPI 1 FSPI 2 FSPI 3 FSPI 4 FSPI 6 eMMC sdmmc Between probing each device, it will try 2 different iomux combinations. If no bootable medium is found, it will bring up a dwc3 gadget on USB3OTG_0 . Once a bootable medium is found, it will load the ddr image from it into sram call it, then load the OS image into dram and run that. Both images are booted into as EL3 in aarch64 mode.","title":"boot()"},{"location":"rk3588/clock/","text":"RK3588 Clocks Example: Setting up v0pll Force PLL into slow mode Connects the PLL to a slow clock to ensure stability while we set it up. CRU_MODE_CON00.clk_v0pll_mode = clk_deepslow (or xin_osc0_func) Power down the PLL CRU_V0PLL_CON1.v0pll_resetb = 1 See calulating settings Set pre-divider value: CRU_V0PLL_CON1.v0pll_p = P set main divider value: CRU_V0PLL_CON0.v0pll_m = M Set scalar value: CRU_V0PLL_CON1.v0pll_s = S Optional: Set DSM: CRU_V0PLL_CON2.v0pll_k = K Power up: CRU_V0PLL_CON1.v0pll_resetb = 0 Wait until PLL is locked: CRU_V0PLL_CON6.v0pll_lock == 1 Calculating settings There are 4 settings that need to be set: P Pre divider value. M Main divider value. S Scalar value K Delta-sigma modulation value. For eliminating noise. TODO: Document this more. The Linux kernel has a pre-calculated table for getting these values: /* _mhz, _p, _m, _s, _k */ RK3588_PLL_RATE(1500000000, 2, 250, 1, 0), RK3588_PLL_RATE(1200000000, 2, 200, 1, 0), RK3588_PLL_RATE(1188000000, 2, 198, 1, 0), RK3588_PLL_RATE(1100000000, 3, 550, 2, 0), RK3588_PLL_RATE(1008000000, 2, 336, 2, 0), RK3588_PLL_RATE(1000000000, 3, 500, 2, 0), RK3588_PLL_RATE(900000000, 2, 300, 2, 0), RK3588_PLL_RATE(850000000, 3, 425, 2, 0), RK3588_PLL_RATE(816000000, 2, 272, 2, 0), RK3588_PLL_RATE(786432000, 2, 262, 2, 9437), RK3588_PLL_RATE(786000000, 1, 131, 2, 0), RK3588_PLL_RATE(742500000, 4, 495, 2, 0), RK3588_PLL_RATE(722534400, 8, 963, 2, 24850), RK3588_PLL_RATE(600000000, 2, 200, 2, 0), RK3588_PLL_RATE(594000000, 2, 198, 2, 0), RK3588_PLL_RATE(200000000, 3, 400, 4, 0), RK3588_PLL_RATE(100000000, 3, 400, 5, 0), And some code to calculate the idela values from an input and output frequency. static struct rockchip_pll_rate_table * rockchip_rk3588_pll_frac_by_auto(unsigned long fin_hz, unsigned long fout_hz) { struct rockchip_pll_rate_table *rate_table = &rockchip_auto_table; u32 p, m, s, k; u64 fvco; for (s = 0; s <= 6; s++) { fvco = (u64)fout_hz << s; if (fvco < RK3588_VCO_MIN_HZ || fvco > RK3588_VCO_MAX_HZ) continue; for (p = 1; p <= 4; p++) { for (m = 64; m <= 1023; m++) { if ((fvco >= m * fin_hz / p) && (fvco < (m + 1) * fin_hz / p)) { //k = rockchip_rk3588_pll_k_get(m, p, s, // fin_hz, // fvco); //if (!k) // continue; rate_table->p = p; rate_table->s = s; rate_table->k = 0; if (k > 32767) rate_table->m = m + 1; else rate_table->m = m; return rate_table; } } } } return NULL; }","title":"RK3588 Clocks"},{"location":"rk3588/clock/#rk3588-clocks","text":"","title":"RK3588 Clocks"},{"location":"rk3588/clock/#example-setting-up-v0pll","text":"Force PLL into slow mode Connects the PLL to a slow clock to ensure stability while we set it up. CRU_MODE_CON00.clk_v0pll_mode = clk_deepslow (or xin_osc0_func) Power down the PLL CRU_V0PLL_CON1.v0pll_resetb = 1 See calulating settings Set pre-divider value: CRU_V0PLL_CON1.v0pll_p = P set main divider value: CRU_V0PLL_CON0.v0pll_m = M Set scalar value: CRU_V0PLL_CON1.v0pll_s = S Optional: Set DSM: CRU_V0PLL_CON2.v0pll_k = K Power up: CRU_V0PLL_CON1.v0pll_resetb = 0 Wait until PLL is locked: CRU_V0PLL_CON6.v0pll_lock == 1","title":"Example: Setting up v0pll"},{"location":"rk3588/clock/#calculating-settings","text":"There are 4 settings that need to be set:","title":"Calculating settings"},{"location":"rk3588/clock/#p","text":"Pre divider value.","title":"P"},{"location":"rk3588/clock/#m","text":"Main divider value.","title":"M"},{"location":"rk3588/clock/#s","text":"Scalar value","title":"S"},{"location":"rk3588/clock/#k","text":"Delta-sigma modulation value. For eliminating noise. TODO: Document this more. The Linux kernel has a pre-calculated table for getting these values: /* _mhz, _p, _m, _s, _k */ RK3588_PLL_RATE(1500000000, 2, 250, 1, 0), RK3588_PLL_RATE(1200000000, 2, 200, 1, 0), RK3588_PLL_RATE(1188000000, 2, 198, 1, 0), RK3588_PLL_RATE(1100000000, 3, 550, 2, 0), RK3588_PLL_RATE(1008000000, 2, 336, 2, 0), RK3588_PLL_RATE(1000000000, 3, 500, 2, 0), RK3588_PLL_RATE(900000000, 2, 300, 2, 0), RK3588_PLL_RATE(850000000, 3, 425, 2, 0), RK3588_PLL_RATE(816000000, 2, 272, 2, 0), RK3588_PLL_RATE(786432000, 2, 262, 2, 9437), RK3588_PLL_RATE(786000000, 1, 131, 2, 0), RK3588_PLL_RATE(742500000, 4, 495, 2, 0), RK3588_PLL_RATE(722534400, 8, 963, 2, 24850), RK3588_PLL_RATE(600000000, 2, 200, 2, 0), RK3588_PLL_RATE(594000000, 2, 198, 2, 0), RK3588_PLL_RATE(200000000, 3, 400, 4, 0), RK3588_PLL_RATE(100000000, 3, 400, 5, 0), And some code to calculate the idela values from an input and output frequency. static struct rockchip_pll_rate_table * rockchip_rk3588_pll_frac_by_auto(unsigned long fin_hz, unsigned long fout_hz) { struct rockchip_pll_rate_table *rate_table = &rockchip_auto_table; u32 p, m, s, k; u64 fvco; for (s = 0; s <= 6; s++) { fvco = (u64)fout_hz << s; if (fvco < RK3588_VCO_MIN_HZ || fvco > RK3588_VCO_MAX_HZ) continue; for (p = 1; p <= 4; p++) { for (m = 64; m <= 1023; m++) { if ((fvco >= m * fin_hz / p) && (fvco < (m + 1) * fin_hz / p)) { //k = rockchip_rk3588_pll_k_get(m, p, s, // fin_hz, // fvco); //if (!k) // continue; rate_table->p = p; rate_table->s = s; rate_table->k = 0; if (k > 32767) rate_table->m = m + 1; else rate_table->m = m; return rate_table; } } } } return NULL; }","title":"K"},{"location":"rk3588/disp/","text":"RK3588 Display Docs Capabilities RK3588S 1x Samsung HDMI/eDP Combo Interface Supports DP-Alt (USBDP Combo PHY) VOP2 1x Designware HDMI TX RK3588 Everything that RK3588S has +1 HDMI/eDP Combo PHY +1 Designware HDMI TX Samsung HDMI TX/EDP Combo PHY (HDPTX) HDMI 2.1 12Gbps Manages all clock lines Serializer Lots of low-level circuits Daniel doesn't understand Synopsis DesignWare HDMI TX Controller HDMI 2.1 Up to 4K120Hz and 8K60Hz SCDC (Status and Control Data Channel Module) over I2C E-EDID over I2C HDCP over I2C Built-in I2C master Lots of modern HDMI stuff I don't understand EDP TX Controller Not much different than the RK3399 EDP TX VOP2 7680x4320@30Hz through DP 7680x4320@60Hz through HDMI PHY 4096x2304@60Hz through eDP MIPI DSI2 4 video ports (not all equal) Cluster (4) 4096x4320 AFBC compression Image scaling Esmart (4) 4096x4320 Smart layer is not recommended AXI 0 Write Back ARGB888 Max 1920x1080 AXI1 can also be used LUT Dolby Vision","title":"RK3588 Display Docs"},{"location":"rk3588/disp/#rk3588-display-docs","text":"","title":"RK3588 Display Docs"},{"location":"rk3588/disp/#capabilities","text":"","title":"Capabilities"},{"location":"rk3588/disp/#rk3588s","text":"1x Samsung HDMI/eDP Combo Interface Supports DP-Alt (USBDP Combo PHY) VOP2 1x Designware HDMI TX","title":"RK3588S"},{"location":"rk3588/disp/#rk3588","text":"Everything that RK3588S has +1 HDMI/eDP Combo PHY +1 Designware HDMI TX","title":"RK3588"},{"location":"rk3588/disp/#samsung-hdmi-txedp-combo-phy-hdptx","text":"HDMI 2.1 12Gbps Manages all clock lines Serializer Lots of low-level circuits Daniel doesn't understand","title":"Samsung HDMI TX/EDP Combo PHY (HDPTX)"},{"location":"rk3588/disp/#synopsis-designware-hdmi-tx-controller","text":"HDMI 2.1 Up to 4K120Hz and 8K60Hz SCDC (Status and Control Data Channel Module) over I2C E-EDID over I2C HDCP over I2C Built-in I2C master Lots of modern HDMI stuff I don't understand","title":"Synopsis DesignWare HDMI TX Controller"},{"location":"rk3588/disp/#edp-tx-controller","text":"Not much different than the RK3399 EDP TX","title":"EDP TX Controller"},{"location":"rk3588/disp/#vop2","text":"7680x4320@30Hz through DP 7680x4320@60Hz through HDMI PHY 4096x2304@60Hz through eDP MIPI DSI2 4 video ports (not all equal) Cluster (4) 4096x4320 AFBC compression Image scaling Esmart (4) 4096x4320 Smart layer is not recommended AXI 0 Write Back ARGB888 Max 1920x1080 AXI1 can also be used LUT Dolby Vision","title":"VOP2"},{"location":"rk3588/hdmi/","text":"RK3588 display init sequence iomux/grf settings A few registers must be setup for the HDMI TX: VO1_GRF_CON3 (for TX0) VO1_GRF_CON6 (for TX1) GRF_SOC_CON7 VO1_GRF_CON9 The iomux settings for SCL and SDA pins for HDMI must be routed to I2C. As documented on wikipedia pins 15 and 16 in the HDMI type A connector are for I2C. This is used primarily to transport the EDID from the display, which has important information like supported resolutions, timing info, refresh rate, etc. (Looking at the TRM, it seems impossible for these pins to be multiplexed over regular I2C???) What were you smoking rockchip??? VOP2 init Note that you cannot read/write some of the HDMI TX registers at this point. Set connection to HDMI 0/eDP/etc in V01_GRF Power on ( power_ctrl ) Turn overlay interface on Config layer_sel , port_sel , dp2_bg_mix_ctrl Setup interface Set regdone_imd_en in regdone_imd_en Setup dsp_inface_pol Setup according to the display device chosen ( dsp_inface_en , dsp_inface_ctrl ) Enable display standby Disable all layers and frame transfer while setup is being done Setup the display (POST) Set all clock/timing settings as needed Set dual_display_ctrl , dsp_bg , scl_ctrl as needed Setup layer Settings depend on what layer system you decide to use Setup Pixel clock source, data source port Set DONE_CFG Video signal is active, all of the HDMI TX registers can be accessed now. https://github.com/yanyitech/coolpi-kernel/blob/b7a84509cc732e4590d988dfcd008842b09b17b0/drivers/gpu/drm/rockchip/rockchip_drm_vop2.c https://github.com/yanyitech/coolpi-kernel/blob/b7a84509cc732e4590d988dfcd008842b09b17b0/drivers/gpu/drm/rockchip/rockchip_vop2_reg.c 2. PHY Setup ( HdptxRopllCmnConfig ) Power everything on Configure clocks ro_ref_clk_sel and lc_ref_clk_sel? Check clock is valid Reset PHY Release APB reset of PHY Write internal registers Configure AUX Reset and enable the lanes Configure PHY main link Clock transmitter settings (?) PLL settings TRM supposedly says what registers to write for all of this Enable PLL Wait until PLL is locked Done Clock setup: https://github.com/yanyitech/coolpi-kernel/blob/b7a84509cc732e4590d988dfcd008842b09b17b0/drivers/phy/rockchip/phy-rockchip-samsung-hdptx-hdmi.c Resets: https://github.com/torvalds/linux/blob/c964ced7726294d40913f2127c3f185a92cb4a41/drivers/clk/rockchip/rst-rk3588.c#L703 3. HDMI TX Setup Reset TX controller Setup I2C controller to communicate with DDC SCDC and get the EDID Rockchip people were smoking something potent when they made this. Configure DW controller Configure the link Configure packet property registers Configure the HDCP 1.4 encoder Configure the decryption seed Configure HDCP memory This can (and should tbh) be skipped Configure audio settings This can be skipped. Configure video settings TODO: More here Configure SCDC (Status and Control Data Channel) Interface Configure the SCDC module over I2C Scrambling TMDS Clock ratio RR enable FRL Rate FFE levels Set video input (VOP2) and audio input Link training We'll try to skip this for now. https://github.com/yanyitech/coolpi-kernel/blob/b7a84509cc732e4590d988dfcd008842b09b17b0/drivers/gpu/drm/bridge/synopsys/dw-hdmi-qp.c https://github.com/yanyitech/coolpi-kernel/blob/b7a84509cc732e4590d988dfcd008842b09b17b0/drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c","title":"RK3588 display init sequence"},{"location":"rk3588/hdmi/#rk3588-display-init-sequence","text":"","title":"RK3588 display init sequence"},{"location":"rk3588/hdmi/#iomuxgrf-settings","text":"A few registers must be setup for the HDMI TX: VO1_GRF_CON3 (for TX0) VO1_GRF_CON6 (for TX1) GRF_SOC_CON7 VO1_GRF_CON9 The iomux settings for SCL and SDA pins for HDMI must be routed to I2C. As documented on wikipedia pins 15 and 16 in the HDMI type A connector are for I2C. This is used primarily to transport the EDID from the display, which has important information like supported resolutions, timing info, refresh rate, etc. (Looking at the TRM, it seems impossible for these pins to be multiplexed over regular I2C???) What were you smoking rockchip???","title":"iomux/grf settings"},{"location":"rk3588/hdmi/#vop2-init","text":"Note that you cannot read/write some of the HDMI TX registers at this point. Set connection to HDMI 0/eDP/etc in V01_GRF Power on ( power_ctrl ) Turn overlay interface on Config layer_sel , port_sel , dp2_bg_mix_ctrl Setup interface Set regdone_imd_en in regdone_imd_en Setup dsp_inface_pol Setup according to the display device chosen ( dsp_inface_en , dsp_inface_ctrl ) Enable display standby Disable all layers and frame transfer while setup is being done Setup the display (POST) Set all clock/timing settings as needed Set dual_display_ctrl , dsp_bg , scl_ctrl as needed Setup layer Settings depend on what layer system you decide to use Setup Pixel clock source, data source port Set DONE_CFG Video signal is active, all of the HDMI TX registers can be accessed now. https://github.com/yanyitech/coolpi-kernel/blob/b7a84509cc732e4590d988dfcd008842b09b17b0/drivers/gpu/drm/rockchip/rockchip_drm_vop2.c https://github.com/yanyitech/coolpi-kernel/blob/b7a84509cc732e4590d988dfcd008842b09b17b0/drivers/gpu/drm/rockchip/rockchip_vop2_reg.c","title":"VOP2 init"},{"location":"rk3588/hdmi/#2-phy-setup","text":"( HdptxRopllCmnConfig ) Power everything on Configure clocks ro_ref_clk_sel and lc_ref_clk_sel? Check clock is valid Reset PHY Release APB reset of PHY Write internal registers Configure AUX Reset and enable the lanes Configure PHY main link Clock transmitter settings (?) PLL settings TRM supposedly says what registers to write for all of this Enable PLL Wait until PLL is locked Done Clock setup: https://github.com/yanyitech/coolpi-kernel/blob/b7a84509cc732e4590d988dfcd008842b09b17b0/drivers/phy/rockchip/phy-rockchip-samsung-hdptx-hdmi.c Resets: https://github.com/torvalds/linux/blob/c964ced7726294d40913f2127c3f185a92cb4a41/drivers/clk/rockchip/rst-rk3588.c#L703","title":"2. PHY Setup"},{"location":"rk3588/hdmi/#3-hdmi-tx-setup","text":"Reset TX controller Setup I2C controller to communicate with DDC SCDC and get the EDID Rockchip people were smoking something potent when they made this. Configure DW controller Configure the link Configure packet property registers Configure the HDCP 1.4 encoder Configure the decryption seed Configure HDCP memory This can (and should tbh) be skipped Configure audio settings This can be skipped. Configure video settings TODO: More here Configure SCDC (Status and Control Data Channel) Interface Configure the SCDC module over I2C Scrambling TMDS Clock ratio RR enable FRL Rate FFE levels Set video input (VOP2) and audio input Link training We'll try to skip this for now. https://github.com/yanyitech/coolpi-kernel/blob/b7a84509cc732e4590d988dfcd008842b09b17b0/drivers/gpu/drm/bridge/synopsys/dw-hdmi-qp.c https://github.com/yanyitech/coolpi-kernel/blob/b7a84509cc732e4590d988dfcd008842b09b17b0/drivers/gpu/drm/rockchip/dw_hdmi-rockchip.c","title":"3. HDMI TX Setup"}]}